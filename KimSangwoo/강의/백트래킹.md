퇴각검색(영어: backtracking, 한국어: 백트래킹)은 한정 조건을 가진 문제를 풀려는 전략이다. "퇴각검색(backtrack)"이란 용어는 1950년대의 미국 수학자 D. H. 레머가 지었다.

백트래킹은 모든 조합을 시도해서 문제의 해를 찾는다. 이것이 장점이 될 수 있는 이유는 백트래킹의 구현 방법들이 많은 부분 조합들을 배제하기 때문이다. 결국 풀이 시간이 단축된다.

주요 개념은 해를 얻을 때까지 모든 가능성을 시도한다는 점이다. 모든 가능성은 하나의 트리처럼 구성할 수 있으며, 가지 중에 해결책이 있다. 트리를 검사하기 위해 깊이 우선 탐색을 사용한다. 탐색 중에 오답을 만나면 이전 분기점으로 돌아간다. 시도해보지 않은 다른 해결 방법이 있으면 시도한다. 해결 방법이 더 없으면 더 이전의 분기점으로 돌아간다. 모든 트리의 노드를 검사해도 답을 못 찾을 경우, 이 문제의 해결책은 없는 것이다.

퇴각검색은 보통 재귀 함수로 구현된다. 재귀로 파생된 해결 방법은 하나 이상의 변수가 필요한데 , 이것은 현재 시점에서 적용할 수 있는 변수값들을 알고 있다. 퇴각검색은 깊이 우선 탐색과 대략 같으나 기억 공간은 덜 차지한다. 현재의 상태를 보관하고 바꾸는 동안만 차지한다. 탐색 속도를 높이기 위해, 재귀 호출을 하기 전에 시도할 값을 정하고 조건(전진 탐색의 경우)을 벗어난 값을 지우는 알고리즘을 적용할 수 있다. 아니면 그 값을 제외한 다른 값들을 탐색할 수도 있다.

```cpp
vector<bool> check(N, false);


void recursion(int M, int count, int index)
{
    if(count==M)
    {
        //출력하거나 배열에 저장
        return;
    }

    for (int i = index; i < N; i++)
    {
        if (!check[i])
        {
            check[i] = true;
            recursion(M, count + 1, i + 1);
            check[i] = false;
        }
    }
}
```

M의 역할:
 선택 되어야 될 원소의 수를 의미함,

count의 역할:
 현재까지 선택한 원소의 수.

index의 역할:
탐색을 시작할 위치


종료 조건: 
count가 M에 도달하면 원하는 개수의 원소를 선택한 것이므로 출력하거나 배열에 저장.

재귀 구조:
아직 선택되지 않은 원소를 찾아(!check[i]), 해당 원소를 선택(check[i] = true)한 후 재귀적으로 다음 원소를 탐색.
재귀가 끝난 후 선택을 취소(check[i] = false)해 백트래킹을 수행.